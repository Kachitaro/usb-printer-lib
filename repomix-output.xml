This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
public/vite.svg
README.md
src/App.jsx
src/main.jsx
src/types.d.ts
src/UsbPrinter.js
src/UsbPrinterProvider.ts
src/WebUSBDemo.tsx
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/types.d.ts">
export interface UsbPrinterOptions {
  vendorId: number;
  productId: number;
}


declare interface USBConnectionEvent extends Event {
  readonly device: USBDevice;
}

export interface USBEndpoint {
  readonly endpointNumber: number;
  readonly direction: "in" | "out";
  readonly type?: string;
}

export interface USBAlternateInterface {
  readonly interfaceClass: number;
  readonly interfaceSubclass: number;
  readonly interfaceProtocol: number;
  readonly endpoints: USBEndpoint[];
}

export interface USBInterface {
  readonly interfaceNumber: number;
  readonly alternates: USBAlternateInterface[];
  readonly claimed?: boolean;
}

export interface USBDevice extends EventTarget {
  readonly productId: number;
  readonly vendorId: number;
  readonly productName: string;
  open(): Promise<void>;
  close(): Promise<void>;
  selectConfiguration(configurationValue: number): Promise<void>;
  claimInterface(interfaceNumber: number): Promise<void>;
  transferOut(endpointNumber: number, data: BufferSource): Promise<USBOutTransferResult>;
  reset(): Promise<void>;
  configuration: RTCConfiguration | null;
  interfaces: USBInterface[];
}

/**
 * Minimal WebUSB types to satisfy transfer result typing.
 * These match the shape used by the WebUSB API: status and optional bytesWritten.
 */
export type USBTransferStatus = "ok" | "stall" | "babble" | "error";

export interface USBOutTransferResult {
  readonly status: USBTransferStatus;
  readonly bytesWritten?: number;
}
</file>

<file path="src/UsbPrinter.js">
// ID c·ªßa m√°y in
const TARGET_VENDOR_ID = 8137;
const TARGET_PRODUCT_ID = 8214;

class UsbPrinter {
    static instance = null;

    static getInstance() {
        if (!UsbPrinter.instance) {
            UsbPrinter.instance = new UsbPrinter();
            UsbPrinter.instance.autoConnect();
        }
        return UsbPrinter.instance;
    }

    constructor() {
        this.device = null;
        this.interfaceNumber = null;
        this.endpointOut = null;
        this.connected = false;

        navigator.usb.addEventListener("disconnect", (event) => {
            if (this.device && event.device.productId === this.device.productId) {
                console.log("üîå M√°y in ƒë√£ b·ªã ng·∫Øt k·∫øt n·ªëi.");
                this.device = null;
                this.connected = false;
            }
        });

        navigator.usb.addEventListener("connect", (event) => {
            if (
                event.device.vendorId === TARGET_VENDOR_ID &&
                event.device.productId === TARGET_PRODUCT_ID
            ) {
                console.log("üîó M√°y in ƒë√£ ƒë∆∞·ª£c c·∫Øm l·∫°i, t·ª± ƒë·ªông k·∫øt n·ªëi...");
                this.setupDevice(event.device);
            }
        });
    }

    async autoConnect() {
        try {
            const devices = await navigator.usb.getDevices();
            const device = devices.find(
                (d) =>
                    d.vendorId === TARGET_VENDOR_ID &&
                    d.productId === TARGET_PRODUCT_ID
            );

            if (device) {
                await this.setupDevice(device);
                console.log("‚úÖ ƒê√£ t·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i m√°y in:", device.productName);
            } else {
                console.log(
                    "Ch∆∞a c√≥ quy·ªÅn truy c·∫≠p m√°y in. C·∫ßn user gesture ƒë·ªÉ c·∫•p quy·ªÅn."
                );
            }
        } catch (err) {
            console.warn("‚ö†Ô∏è L·ªói khi auto-connect m√°y in:", err.message);
        }
    }

    async requestPermission() {
        try {
            const device = await navigator.usb.requestDevice({
                filters: [{ vendorId: TARGET_VENDOR_ID, productId: TARGET_PRODUCT_ID }],
            });
            await this.setupDevice(device);
            localStorage.setItem("printerAllowed", "true");
            console.log("‚úÖ ƒê√£ c·∫•p quy·ªÅn v√† k·∫øt n·ªëi m√°y in:", device.productName);
        } catch (err) {
            if (err.message.includes("No device selected")) {
                console.log("‚ùé Ng∆∞·ªùi d√πng hu·ª∑ c·∫•p quy·ªÅn thi·∫øt b·ªã.");
            } else {
                console.error("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi m√°y in:", err);
            }
        }
    }

    async setupDevice(device) {
        await device.open();
        if (!device.configuration) await device.selectConfiguration(1);
        const iface = device.configuration.interfaces.find((i) =>
            i.alternates[0].endpoints.some((e) => e.direction === "out")
        );
        await device.claimInterface(iface.interfaceNumber);
        this.device = device;
        this.interfaceNumber = iface.interfaceNumber;
        this.endpointOut = iface.alternates[0].endpoints.find(
            (e) => e.direction === "out"
        ).endpointNumber;
        this.connected = true;
    }

    async printRaw(data) {
        if (!this.device) throw new Error("‚ö†Ô∏è Ch∆∞a k·∫øt n·ªëi m√°y in.");
        if (!(data instanceof Uint8Array)) data = new TextEncoder().encode(data);
        await this.device.transferOut(this.endpointOut, data);
    }

    async printText(text) {
        const encoder = new TextEncoder();
        const ESC = "\x1b";
        const reset = `${ESC}@`;
        const cmd = encoder.encode(reset + text + "\n");
        await this.printRaw(cmd);
        await this.feed();
        await this.cut();
    }

    async feed(lines = 5) {
        await this.printRaw(new Uint8Array([0x1b, 0x64, lines]));
    }

    async cut() {
        await this.printRaw(new Uint8Array([0x1d, 0x56, 0x00]));
    }

    async printPdf() { }
}

export default UsbPrinter;
</file>

<file path="src/UsbPrinterProvider.ts">
import { USBConnectionEvent, USBDevice } from "./types";

export class UsbPrinterProvider {
  private static instance: UsbPrinterProvider | null = null;
  private interfaceNumber: number | null = null;
  private device: USBDevice | null = null;
  private endpointOut: number | null = null;
  private connected = false;

  private readonly vendorId: number;
  private readonly productId: number;

  constructor(vendorId: number, productId: number) {
    this.vendorId = vendorId;
    this.productId = productId;

    (navigator as any).usb.addEventListener("disconnect", (event: USBConnectionEvent) => {
      if (this.device && event.device.productId === this.device.productId) {
        console.log("M√°y in ƒë√£ b·ªã ng·∫Øt k·∫øt n·ªëi.");
        this.device = null;
        this.connected = false;
      }
    });

    (navigator as any).usb.addEventListener("connect", (event: USBConnectionEvent) => {
      if (
        event.device.vendorId === this.vendorId &&
        event.device.productId === this.productId
      ) {
        console.log("M√°y in ƒë√£ ƒë∆∞·ª£c c·∫Øm l·∫°i, t·ª± ƒë·ªông k·∫øt n·ªëi...");
        this.setupDevice(event.device).catch(console.error);
      }
    });
  }

  static getInstance(vendorId: number, productId: number): UsbPrinterProvider {
    if (!UsbPrinterProvider.instance) {
      UsbPrinterProvider.instance = new UsbPrinterProvider(vendorId, productId);
      UsbPrinterProvider.instance.autoConnect();
    }
    return UsbPrinterProvider.instance;
  }

  private async autoConnect(): Promise<void> {
    try {
      const devices = await (navigator as any).usb.getDevices();
      const device = devices.find(
        (d: { vendorId: number; productId: number; }) => d.vendorId === this.vendorId && d.productId === this.productId
      );

      if (device) {
        await this.setupDevice(device);
        console.log("ƒê√£ t·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i m√°y in:", device.productName);
      } else {
        console.log("Ch∆∞a c√≥ quy·ªÅn truy c·∫≠p m√°y in. C·∫ßn user gesture ƒë·ªÉ c·∫•p quy·ªÅn.");
      }
    } catch (err) {
      console.warn("L·ªói khi auto-connect m√°y in:", (err as Error).message);
    }
  }

  async requestPermission(): Promise<void> {
    try {
      const device = await (navigator as any).usb.requestDevice({
        filters: [{ vendorId: this.vendorId, productId: this.productId }],
      });
      await this.setupDevice(device);
      localStorage.setItem("printerAllowed", "true");
      console.log("ƒê√£ c·∫•p quy·ªÅn v√† k·∫øt n·ªëi m√°y in:", device.productName);
    } catch (err) {
      const message = (err as Error).message;
      if (message.includes("No device selected")) {
        console.log("Ng∆∞·ªùi d√πng hu·ª∑ c·∫•p quy·ªÅn thi·∫øt b·ªã.");
      } else {
        console.error("Kh√¥ng th·ªÉ k·∫øt n·ªëi m√°y in:", err);
      }
    }
  }

  private async setupDevice(device: USBDevice): Promise<void> {
    await device.open();
    if (!device.configuration) {
      await device.selectConfiguration(1);
    }

    const configuration = (device as any).configuration;
    if (!configuration) {
      throw new Error("Kh√¥ng t√¨m th·∫•y configuration c·ªßa thi·∫øt b·ªã.");
    }

    const iface = (configuration as any).interfaces.find((i: any) =>
      i.alternates[0].endpoints.some((e: any) => e.direction === "out")
    );

    if (!iface) throw new Error("Kh√¥ng t√¨m th·∫•y interface c√≥ endpoint OUT.");

    await device.claimInterface(iface.interfaceNumber);

    const endpointOut = iface.alternates[0].endpoints.find(
      (e: any) => e.direction === "out"
    );

    if (!endpointOut) throw new Error("Kh√¥ng t√¨m th·∫•y endpoint OUT.");

    this.device = device;
    this.interfaceNumber = iface.interfaceNumber;
    this.endpointOut = endpointOut.endpointNumber;
    this.connected = true;
  }

  async printRaw(data: Uint8Array | string): Promise<void> {
    if (!this.device || this.endpointOut == null) {
      throw new Error("‚ö†Ô∏è Ch∆∞a k·∫øt n·ªëi m√°y in.");
    }

    const buffer = data instanceof Uint8Array ? data : new TextEncoder().encode(data);
    const safeView =
      buffer.byteOffset === 0 && buffer.byteLength === buffer.buffer.byteLength
        ? buffer
        : buffer.slice();

    const arrayBufferToSend = safeView.buffer as ArrayBuffer;

    await this.device.transferOut(this.endpointOut, arrayBufferToSend);
  }

  async printText(text: string): Promise<void> {
    const encoder = new TextEncoder();
    const ESC = "\x1b";
    const reset = `${ESC}@`;
    const cmd = encoder.encode(reset + text + "\n");
    await this.printRaw(cmd);
    await this.feed();
    await this.cut();
  }

  async feed(lines = 5): Promise<void> {
    await this.printRaw(new Uint8Array([0x1b, 0x64, lines]));
  }

  async cut(): Promise<void> {
    await this.printRaw(new Uint8Array([0x1d, 0x56, 0x00]));
  }

  async printPdf(): Promise<void> {
    // TODO: Implement PDF printing logic if needed
  }

  isConnected(): boolean {
    return this.connected;
  }
}
</file>

<file path="src/WebUSBDemo.tsx">
import { UsbPrinterProvider } from "./UsbPrinterProvider";

export default function WebUSBDemo() {
    const printer = UsbPrinterProvider.getInstance(8137, 8214);
    const text =
        "[C]   <font size='big'>PHI·∫æU THANH TO√ÅN</font>\n[C] ----------------------------------------\n[L]    Ng√†y:                         2025-09-11\n[L]    Gi·ªù v√†o:                           15:18\n[L]    Ho√° ƒë∆°n#                           DNN83\n[L]    Nh√¢n vi√™n:                         ngant\n[C] ----------------------------------------\n[L]    SL  ƒêG                    TT         SGG\n[L]    TR√äN 1M4 - C·ªîNG CH√çNH                   \n[L]    1   220,000          220,000     220,000\n[C] ----------------------------------------\n[L]    TH√ÄNH TI·ªÄN:                  220,000 VND\n[L]    PHI·∫æU MUA H√ÄNG :                   0 VND\n[L]    GI·∫¢M GI√Å :                         0 VND\n[C] ----------------------------------------\n[L]    THANH TO√ÅN:                  220,000 VND\n[L]    PH∆Ø∆†NG TH·ª®C THANH TO√ÅN:         TI·ªÄN M·∫∂T\n[C] -----------------------------------------\n" +
        "[C]<barcode type='128' width='40' text='above'>{BDantSu</barcode>\n" +
        "[C]       Qu√©t QR & xu·∫•t ho√° ƒë∆°n\n[C]   \n[C]<qrcode size='30'>https://inv.dev.nexbus.net/DNN83/cwvcfcu4vagnes1e</qrcode>\n\n[C]     L∆∞u √Ω: C·∫≠p nh·∫≠t th√¥ng tin xu·∫•t h√≥a ƒë∆°n   \n[C]     trong v√≤ng 120 ph√∫t k·ªÉ t·ª´ l√∫c mua h√†ng   \n[C]     v√† ch·ªâ √°p d·ª•ng trong ng√†y (tr∆∞·ªõc 17:00)    \n\n[C]        C·∫£m ∆°n v√† h·∫πn g·∫∑p l·∫°i qu√Ω kh√°ch\n\n"

    return (
        <div>
            <h2>WebUSB Demo</h2>
            <button onClick={() => printer.requestPermission()}>
                K·∫øt n·ªëi m√°y in USB
            </button>
            <button onClick={() => printer.printText(text)}>
                In vƒÉn b·∫£n
            </button>
        </div>
    );
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>react-usb-demo</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="src/main.jsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="package.json">
{
  "name": "react-usb-demo",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.546.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "vite": "npm:rolldown-vite@7.1.14"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.1.14"
  }
}
</file>

<file path="src/App.jsx">
import WebUSBDemo from './WebUSBDemo.jsx'

function App() {
  return (
    <>
      <h1>Vite + React</h1>
      <WebUSBDemo />
    </>
  )
}

export default App
</file>

</files>
